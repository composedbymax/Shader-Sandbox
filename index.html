<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLSL editor - MW</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: Consolas, Menlo, monospace; }
    #app { display: flex; height: 100%; }
    #editors { width: 40%; background: #1e1e1e; display: flex; flex-direction: column; border-right: 1px solid #333; position: relative; }
    .editor-panel { flex: none; display: flex; flex-direction: column; overflow: hidden; }
    .panel-header { background: #252526; color: #bbb; padding: 6px 10px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
    .panel-header input { font-size: 0.8em; }
    #rowDivider { height: 6px; background: #333; cursor: row-resize; flex: none;}
    textarea { flex: 1; background: #1e1e1e; color: #d4d4d4; border: none; padding: 10px; font-size: 0.95em; line-height: 1.4; resize: none; overflow: auto; outline: none; }
    #divider { width: 6px; background: #333; cursor: col-resize; }
    #divider:hover { background: #555; }
    #preview-panel { flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; }
    #lint { position: absolute; bottom: 0; left: 0; width: 100%; max-height: 20%; background: rgba(17,17,17,0.9); color: #f88; padding: 8px; font-size: 0.9em; overflow: auto; white-space: pre-wrap; }
    #glcanvas { width: 100%; height: 100%; display: block; }
    #fsBtn { position: absolute; top: 12px; right: 12px; z-index: 10; background: #252526; color: #bbb; border: none; padding: 6px 10px; font-size: 1em; cursor: pointer; }
    #fsBtn:hover { background: #333; }
  </style>
</head>
<body>
  <div id="app">
    <div id="editors">
      <div id="vertPanel" class="editor-panel">
        <div class="panel-header">
          Vertex Shader
          <input type="file" id="vertFile" accept=".vert,.vs,.txt" />
        </div>
        <textarea id="vertCode">
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0., 1.);
}</textarea>
      </div>
      <div id="rowDivider"></div>
      <div id="fragPanel" class="editor-panel">
        <div class="panel-header">
          Fragment Shader
          <input type="file" id="fragFile" accept=".frag,.fs,.txt" />
        </div>
        <textarea id="fragCode">precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec3 col = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0,2,4));
  gl_FragColor = vec4(col,1.0);
}</textarea>
      </div>
    </div>
    <div id="divider"></div>
    <div id="preview-panel">
      <canvas id="glcanvas"></canvas>
      <button id="fsBtn">⛶</button>
      <div id="lint"></div>
    </div>
  </div>
  <script>
  (function(){
    const $ = id => document.getElementById(id);
    const app = $('app'), 
          editors = $('editors'),
          vertPanel = $('vertPanel'),
          fragPanel = $('fragPanel'),
          rowDivider = $('rowDivider'),
          divider = $('divider'),
          previewPanel = $('preview-panel'),
          canvas = $('glcanvas'),
          vertTA = $('vertCode'),
          fragTA = $('fragCode'),
          vertFile = $('vertFile'),
          fragFile = $('fragFile'),
          fsBtn = $('fsBtn'),
          lintDiv = $('lint');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) { alert('WebGL not supported'); return; }
    let program = null,
        attribLoc = null,
        uTimeLoc = null,
        uResLoc = null,
        startTime = performance.now(),
        drag = { type: null, startPos: 0, startSize: 0 };
    const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    function initSplit() {
      const totalH = editors.clientHeight - rowDivider.offsetHeight;
      vertPanel.style.height = fragPanel.style.height = (totalH / 2) + 'px';
      resizeCanvas();
    }
    function resizeCanvas() {
      const w = previewPanel.clientWidth, h = previewPanel.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        gl.viewport(0, 0, w, h);
      }
    }
    function compileShader(src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        const err = gl.getShaderInfoLog(s);
        gl.deleteShader(s);
        return { shader: null, error: err };
      }
      return { shader: s, error: null };
    }
    function rebuildProgram() {
      resizeCanvas();
      lintDiv.textContent = '';
      if (program) gl.deleteProgram(program);
      const errors = [];
      const vs = compileShader(vertTA.value, gl.VERTEX_SHADER);
      const fs = compileShader(fragTA.value, gl.FRAGMENT_SHADER);
      if (vs.error) errors.push('Vertex: ' + vs.error);
      if (fs.error) errors.push('Fragment: ' + fs.error);
      if (errors.length) {
        lintDiv.textContent = errors.join('\n');
        return;
      }
      const p = gl.createProgram();
      gl.attachShader(p, vs.shader);
      gl.attachShader(p, fs.shader);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        lintDiv.textContent = 'Link: ' + gl.getProgramInfoLog(p);
        gl.deleteProgram(p);
        return;
      }
      program = p;
      gl.useProgram(program);
      attribLoc = gl.getAttribLocation(program, 'a_position');
      uTimeLoc = gl.getUniformLocation(program, 'u_time');
      uResLoc = gl.getUniformLocation(program, 'u_resolution');
      gl.enableVertexAttribArray(attribLoc);
      gl.vertexAttribPointer(attribLoc, 2, gl.FLOAT, false, 0, 0);
    }
    function render() {
      if (!program) return;
      resizeCanvas();
      gl.useProgram(program);
      gl.uniform1f(uTimeLoc, (performance.now() - startTime) * 0.001);
      gl.uniform2f(uResLoc, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    window.addEventListener('load', initSplit);
    window.addEventListener('resize', initSplit);
    ['mousedown', 'touchstart'].forEach(evt => {
      rowDivider.addEventListener(evt, e => {
        drag.type = 'row';
        drag.startPos = e.clientY || e.touches[0].clientY;
        drag.startSize = vertPanel.getBoundingClientRect().height;
        e.preventDefault();
      }, { passive: false });
      divider.addEventListener(evt, e => {
        drag.type = 'col';
        drag.startPos = e.clientX || e.touches[0].clientX;
        drag.startSize = editors.getBoundingClientRect().width;
        e.preventDefault();
      }, { passive: false });
    });
    ['mousemove', 'touchmove'].forEach(evt => {
      document.addEventListener(evt, e => {
        if (!drag.type) return;
        const pos = evt.includes('touch') ? 
          (e.touches[0][drag.type === 'row' ? 'clientY' : 'clientX']) : 
          (e[drag.type === 'row' ? 'clientY' : 'clientX']);
        if (drag.type === 'row') {
          const dy = pos - drag.startPos;
          const totalH = editors.clientHeight - rowDivider.offsetHeight;
          let topH = Math.max(50, Math.min(totalH - 50, drag.startSize + dy));
          vertPanel.style.height = topH + 'px';
          fragPanel.style.height = (totalH - topH) + 'px';
        } else {
          const newW = Math.max(100, Math.min(app.clientWidth - 100, drag.startSize + pos - drag.startPos));
          editors.style.width = newW + 'px';
        }
        resizeCanvas();
        e.preventDefault();
      });
    });
    ['mouseup', 'touchend', 'touchcancel'].forEach(evt => {
      document.addEventListener(evt, () => drag.type = null);
    });
    function handleFile(input, ta) {
      if (!input.files.length) return;
      const r = new FileReader();
      r.onload = e => { ta.value = e.target.result; rebuildProgram(); };
      r.readAsText(input.files[0]);
    }
    [vertTA, fragTA].forEach(ta => ta.addEventListener('input', rebuildProgram));
    vertFile.addEventListener('change', () => handleFile(vertFile, vertTA));
    fragFile.addEventListener('change', () => handleFile(fragFile, fragTA));
    fsBtn.addEventListener('click', () => {
      const fsElement = document.fullscreenElement || document.webkitFullscreenElement;
      if (!fsElement) {
        const request = previewPanel.requestFullscreen || previewPanel.webkitRequestFullscreen;
        request.call(previewPanel);
      } else {
        const exit = document.exitFullscreen || document.webkitExitFullscreen;
        exit.call(document);
      }
    });
    ['fullscreenchange', 'webkitfullscreenchange'].forEach(evt => {
      document.addEventListener(evt, () => {
        resizeCanvas();
        fsBtn.textContent = (document.fullscreenElement || document.webkitFullscreenElement) ? '✕' : '⛶';
      });
    });
    rebuildProgram();
    render();
  })();
  </script>
</body>
</html>