<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLSL editor - MW</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: Consolas, Menlo, monospace; }
    #app { display: flex; height: 100%; }
    #editors { width: 40%; background: #1e1e1e; display: flex; flex-direction: column; border-right: 1px solid #333; position: relative; }
    .editor-panel { flex: none; display: flex; flex-direction: column; overflow: hidden; }
    .panel-header { background: #252526; color: #bbb; padding: 6px 10px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
    .panel-header input { font-size: 0.8em; }
    #rowDivider { height: 5px; background: #333; cursor: row-resize; }
    textarea { flex: 1; background: #1e1e1e; color: #d4d4d4; border: none; padding: 10px; font-size: 0.95em; line-height: 1.4; resize: none; overflow: auto; outline: none; }
    #divider { width: 5px; background: #333; cursor: col-resize; }
    #divider:hover { background: #555; }
    #preview-panel { flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; }
    #lint { position: absolute; bottom: 0; left: 0; width: 100%; max-height: 20%; background: rgba(17,17,17,0.9); color: #f88; padding: 8px; font-size: 0.9em; overflow: auto; white-space: pre-wrap; }
    #glcanvas { width: 100%; height: 100%; display: block; }
    #fsBtn { position: absolute; top: 12px; right: 12px; z-index: 10; background: #252526; color: #bbb; border: none; padding: 6px 10px; font-size: 1em; cursor: pointer; }
    #fsBtn:hover { background: #333; }
  </style>
</head>
<body>
  <div id="app">
    <div id="editors">
      <div id="vertPanel" class="editor-panel">
        <div class="panel-header">
          Vertex Shader
          <input type="file" id="vertFile" accept=".vert,.vs,.txt" />
        </div>
        <textarea id="vertCode">attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0., 1.);
}</textarea>
      </div>
      <div id="rowDivider"></div>
      <div id="fragPanel" class="editor-panel">
        <div class="panel-header">
          Fragment Shader
          <input type="file" id="fragFile" accept=".frag,.fs,.txt" />
        </div>
        <textarea id="fragCode">precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec3 col = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0,2,4));
  gl_FragColor = vec4(col,1.0);
}</textarea>
      </div>
    </div>
    <div id="divider"></div>
    <div id="preview-panel">
      <canvas id="glcanvas"></canvas>
      <button id="fsBtn">⛶</button>
      <div id="lint"></div>
    </div>
  </div>
  <script>
  (function(){
    const app         = document.getElementById('app');
    const editors     = document.getElementById('editors');
    const vertPanel   = document.getElementById('vertPanel');
    const fragPanel   = document.getElementById('fragPanel');
    const rowDivider  = document.getElementById('rowDivider');
    const divider     = document.getElementById('divider');
    const canvas      = document.getElementById('glcanvas');
    const gl          = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) { alert('WebGL not supported'); return; }
    const vertTA      = document.getElementById('vertCode');
    const fragTA      = document.getElementById('fragCode');
    const vertFile    = document.getElementById('vertFile');
    const fragFile    = document.getElementById('fragFile');
    const fsBtn       = document.getElementById('fsBtn');
    const previewPanel= document.getElementById('preview-panel');
    const lintDiv     = document.getElementById('lint');
    function initSplit() {
      const totalH = editors.clientHeight - rowDivider.offsetHeight;
      const half   = totalH / 2;
      vertPanel.style.height = half + 'px';
      fragPanel.style.height = half + 'px';
    }
    window.addEventListener('load', initSplit);
    window.addEventListener('resize', () => { initSplit(); resizeCanvas(); });
    let isRowDragging = false, startY, startTopH;
    rowDivider.addEventListener('mousedown', e => {
      isRowDragging = true;
      startY        = e.clientY;
      startTopH     = vertPanel.getBoundingClientRect().height;
    });
    document.addEventListener('mousemove', e => {
      if (!isRowDragging) return;
      const dy     = e.clientY - startY;
      const totalH = editors.clientHeight - rowDivider.offsetHeight;
      let newTop   = startTopH + dy;
      newTop       = Math.max(50, Math.min(totalH - 50, newTop));
      vertPanel.style.height = newTop + 'px';
      fragPanel.style.height = (totalH - newTop) + 'px';
      resizeCanvas();
    });
    document.addEventListener('mouseup', () => { isRowDragging = false; });
    let isColDragging = false;
    divider.addEventListener('mousedown', () => { isColDragging = true; });
    document.addEventListener('mouseup', () => { isColDragging = false; });
    document.addEventListener('mousemove', (e) => {
      if (!isColDragging) return;
      const rect = app.getBoundingClientRect();
      let newW   = e.clientX - rect.left;
      newW       = Math.max(100, Math.min(rect.width - 100, newW));
      editors.style.width = newW + 'px';
      resizeCanvas();
    });
    function resizeCanvas(){
      const w = previewPanel.clientWidth;
      const h = previewPanel.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        gl.viewport(0,0,w,h);
      }
    }
    const quadVerts = new Float32Array([
      -1,-1,  1,-1,  -1,1,
      -1,1,   1,-1,   1,1
    ]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    let program = null;
    let attribLoc = null, uTimeLoc = null, uResLoc = null;
    let startTime = performance.now();
    function compileShader(src, type){
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        return { shader: null, error: info };
      }
      return { shader, error: null };
    }
    function rebuildProgram(){
      resizeCanvas();
      lintDiv.textContent = '';
      if (program) gl.deleteProgram(program);
      const errors = [];
      const vs = compileShader(vertTA.value, gl.VERTEX_SHADER);
      if (vs.error) errors.push('Vertex: ' + vs.error);
      const fs = compileShader(fragTA.value, gl.FRAGMENT_SHADER);
      if (fs.error) errors.push('Fragment: ' + fs.error);
      if (errors.length) {
        lintDiv.textContent = errors.join('\n');
        return;
      }
      const p = gl.createProgram();
      gl.attachShader(p, vs.shader);
      gl.attachShader(p, fs.shader);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        lintDiv.textContent = 'Link: ' + gl.getProgramInfoLog(p);
        gl.deleteProgram(p);
        return;
      }
      program = p;
      gl.useProgram(program);
      attribLoc = gl.getAttribLocation(program, 'a_position');
      uTimeLoc  = gl.getUniformLocation(program, 'u_time');
      uResLoc   = gl.getUniformLocation(program, 'u_resolution');
      gl.enableVertexAttribArray(attribLoc);
      gl.vertexAttribPointer(attribLoc, 2, gl.FLOAT, false, 0, 0);
    }
    function render(){
      if (!program) return;
      resizeCanvas();
      const t = (performance.now() - startTime)*0.001;
      gl.useProgram(program);
      gl.uniform1f(uTimeLoc, t);
      gl.uniform2f(uResLoc, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    function animate(){ render(); requestAnimationFrame(animate); }
    [vertTA, fragTA].forEach(ta => ta.addEventListener('input', rebuildProgram));
    function handleFile(input, ta){
      if (!input.files.length) return;
      const r = new FileReader();
      r.onload = e => { ta.value = e.target.result; rebuildProgram(); };
      r.readAsText(input.files[0]);
    }
    vertFile.addEventListener('change', ()=> handleFile(vertFile, vertTA));
    fragFile.addEventListener('change', ()=> handleFile(fragFile, fragTA));
    fsBtn.addEventListener('click', () => {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        (previewPanel.requestFullscreen||previewPanel.webkitRequestFullscreen).call(previewPanel);
      } else {
        (document.exitFullscreen||document.webkitExitFullscreen).call(document);
      }
    });
    document.addEventListener('fullscreenchange', onFSChange);
    document.addEventListener('webkitfullscreenchange', onFSChange);
    function onFSChange(){
      resizeCanvas();
      fsBtn.textContent = (document.fullscreenElement||document.webkitFullscreenElement)? '✕':'⛶';
    }
    rebuildProgram();
    animate();
  })();
  </script>
</body>
</html>