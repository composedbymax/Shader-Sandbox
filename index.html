<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GLSL editor - MW</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; 
    --0:rgba(0, 0, 0, 0.7);
    --1:#000;
    --2:#1e1e1e;
    --3:#252526;
    --4:#333;
    --5:#444;
    --6:#bbb;
    --r:#9e0000c8;
    --pad: 6px 10px;
    }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: Consolas, Menlo, monospace; }
    #app { display: flex; height: 100%; }
    #editors { width: 40%; background: var(--2); display: flex; flex-direction: column; border-right: 1px solid var(--4); position: relative; }
    .editor-panel { flex: none; display: flex; flex-direction: column; overflow: hidden; }
    .panel-header { background: var(--3); color: var(--6); padding: var(--pad); font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
    .panel-header input[type=file] { display: none; }
    .file-name { margin-left: 8px; color: var(--6); font-size: 0.9em; }
    .panel-header button {background: var(--4);border: none;padding: 2px 6px;cursor: pointer;}
    .panel-header button:hover, #divider:hover,#fsBtn:hover {background: var(--5);}
    #rowDivider { height: 6px; background: var(--4); cursor: row-resize; flex: none;}
    textarea { flex: 1; background: var(--2); color: var(--6); border: none; padding: var(--pad); font-size: 0.95em; line-height: 1.4; resize: none; overflow: auto; outline: none; }
    #divider { width: 6px; background: var(--4); cursor: col-resize; }
    #preview-panel { flex: 1; position: relative; background: var(--1); display: flex; justify-content: center; align-items: center; }
    #lint { position: absolute; bottom: 0; left: 0; width: 100%; max-height: 20%; background: var(--0); color: var(--r); font-size: 0.9em; overflow: auto; white-space: pre-wrap; }
    #glcanvas { width: 100%; height: 100%; display: block; }
    #fsBtn { position: absolute; top: 12px; right: 12px; z-index: 10; background: var(--4); color: var(--6); border: none; padding: var(--pad); font-size: 1em; cursor: pointer; }
    .expbtn {position: absolute;bottom: 12px;right: 12px;background: var(--4);color: var(--6);padding: var(--pad);border: none;cursor: pointer;}.expbtn:hover {background:var(--5);}
  </style>
</head>
<body>
  <div id="app">
    <div id="editors">
      <div id="vertPanel" class="editor-panel">
        <div class="panel-header">
            <span>Vertex Shader</span>
            <button type="button" id="vertFileBtn">Choose File<span class="file-name" id="vertFileName"></span></button>
            <input type="file" id="vertFile" accept=".vert,.vs,.txt" />
        </div>
        <textarea id="vertCode">
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0., 1.);
}</textarea>
      </div>
      <div id="rowDivider"></div>
      <div id="fragPanel" class="editor-panel">
        <div class="panel-header">
            <span>Fragment Shader</span>
            <button type="button" id="fragFileBtn">Choose File<span class="file-name" id="fragFileName"></span></button>
            <input type="file" id="fragFile" accept=".frag,.fs,.txt" />
        </div>
        <textarea id="fragCode">precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec3 col = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0,2,4));
  gl_FragColor = vec4(col,1.0);
}</textarea>
      </div>
    </div>
    <div id="divider"></div>
    <div id="preview-panel">
      <canvas id="glcanvas"></canvas>
      <button id="fsBtn">⛶</button>
      <div id="lint"></div>
    </div>
  </div>
  <script>
  (function(){
    const $ = id => document.getElementById(id);
    const app = $('app'), 
          editors = $('editors'),
          vertPanel = $('vertPanel'),
          fragPanel = $('fragPanel'),
          rowDivider = $('rowDivider'),
          divider = $('divider'),
          previewPanel = $('preview-panel'),
          canvas = $('glcanvas'),
          vertTA = $('vertCode'),
          fragTA = $('fragCode'),
          vertFile = $('vertFile'),
          fragFile = $('fragFile'),
          vertFileBtn = $('vertFileBtn'),
          fragFileBtn = $('fragFileBtn'),
          vertFileName = $('vertFileName'),
          fragFileName = $('fragFileName'),
          vertExportBtn = $('vertExportBtn'),
          fragExportBtn = $('fragExportBtn'),
          fsBtn = $('fsBtn'),
          lintDiv = $('lint');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) { alert('WebGL not supported'); return; }
    let program = null,
        attribLoc = null,
        uTimeLoc = null,
        uResLoc = null,
        startTime = performance.now(),
        drag = { type: null, startPos: 0, startSize: 0 };
    const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    function initSplit() {
      const totalH = editors.clientHeight - rowDivider.offsetHeight;
      vertPanel.style.height = fragPanel.style.height = (totalH / 2) + 'px';
      resizeCanvas();
    }
    function resizeCanvas() {
      const w = previewPanel.clientWidth, h = previewPanel.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        gl.viewport(0, 0, w, h);
      }
    }
    function compileShader(src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        const err = gl.getShaderInfoLog(s);
        gl.deleteShader(s);
        return { shader: null, error: err };
      }
      return { shader: s, error: null };
    }
    function rebuildProgram() {
      resizeCanvas();
      lintDiv.textContent = '';
      if (program) gl.deleteProgram(program);
      const errors = [];
      const vs = compileShader(vertTA.value, gl.VERTEX_SHADER);
      const fs = compileShader(fragTA.value, gl.FRAGMENT_SHADER);
      if (vs.error) errors.push('Vertex: ' + vs.error);
      if (fs.error) errors.push('Fragment: ' + fs.error);
      if (errors.length) {
        lintDiv.textContent = errors.join('\n');
        return;
      }
      const p = gl.createProgram();
      gl.attachShader(p, vs.shader);
      gl.attachShader(p, fs.shader);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        lintDiv.textContent = 'Link: ' + gl.getProgramInfoLog(p);
        gl.deleteProgram(p);
        return;
      }
      program = p;
      gl.useProgram(program);
      attribLoc = gl.getAttribLocation(program, 'a_position');
      uTimeLoc = gl.getUniformLocation(program, 'u_time');
      uResLoc = gl.getUniformLocation(program, 'u_resolution');
      gl.enableVertexAttribArray(attribLoc);
      gl.vertexAttribPointer(attribLoc, 2, gl.FLOAT, false, 0, 0);
    }
    function render() {
      if (!program) return;
      resizeCanvas();
      gl.useProgram(program);
      gl.uniform1f(uTimeLoc, (performance.now() - startTime) * 0.001);
      gl.uniform2f(uResLoc, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    function exportShader(type, content) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `shader.${type}`;
      a.click();
      URL.revokeObjectURL(url);
    }
    function handleFile(input, ta) {
      if (!input.files.length) return;
      const r = new FileReader();
      r.onload = e => { ta.value = e.target.result; rebuildProgram(); };
      r.readAsText(input.files[0]);
    }
    function handleFileDrop(file, ta, nameSpan) {
      const ext = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();
      const allowed = ['.txt','.vert','.vs','.frag','.fs'];
      if (!allowed.includes(ext)) return;
      const r = new FileReader();
      r.onload = e => { ta.value = e.target.result; rebuildProgram(); };
      r.readAsText(file);
      nameSpan.textContent = file.name;
    }
    vertFileBtn.onclick = () => vertFile.click();
    fragFileBtn.onclick = () => fragFile.click();
    vertFile.addEventListener('change', () => {
      vertFileName.textContent = vertFile.files.length ? vertFile.files[0].name : '';
      handleFile(vertFile, vertTA);
    });
    fragFile.addEventListener('change', () => {
      fragFileName.textContent = fragFile.files.length ? fragFile.files[0].name : '';
      handleFile(fragFile, fragTA);
    });
    ['dragover', 'dragenter'].forEach(evt => {
      vertTA.addEventListener(evt, e => e.preventDefault());
      fragTA.addEventListener(evt, e => e.preventDefault());
    });
    vertTA.addEventListener('drop', e => {
      e.preventDefault();
      if (e.dataTransfer.files.length) 
        handleFileDrop(e.dataTransfer.files[0], vertTA, vertFileName);
    });
    fragTA.addEventListener('drop', e => {
      e.preventDefault();
      if (e.dataTransfer.files.length)
        handleFileDrop(e.dataTransfer.files[0], fragTA, fragFileName);
    });
    function exportFullHTML() {
      const template = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL Animation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    (function(){
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
      if (!gl) { alert('WebGL not supported'); return; }
      const vertexShader = \`${vertTA.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`')}\`;
      const fragmentShader = \`${fragTA.value.replace(/\\/g, '\\\\').replace(/`/g, '\\`')}\`;
      function compileShader(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
          return null;
        }
        return s;
      }
      const vs = compileShader(vertexShader, gl.VERTEX_SHADER);
      const fs = compileShader(fragmentShader, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return;
      }
      const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
      const attribLoc = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(attribLoc);
      gl.vertexAttribPointer(attribLoc, 2, gl.FLOAT, false, 0, 0);
      const uTimeLoc = gl.getUniformLocation(program, 'u_time');
      const uResLoc = gl.getUniformLocation(program, 'u_resolution');
      const startTime = performance.now();
      function resize() {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          gl.viewport(0, 0, w, h);
        }
      }
      function render() {
        resize();
        gl.useProgram(program);
        gl.uniform1f(uTimeLoc, (performance.now() - startTime) * 0.001);
        gl.uniform2f(uResLoc, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      render();
    })();
  <\/script>
</body>
</html>`;
      const blob = new Blob([template], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'webgl.html';
      a.click();
      URL.revokeObjectURL(url);
    }
    function addExportButtons() {
      const vertExportBtn = document.createElement('button');
      vertExportBtn.textContent = 'Export';
      vertExportBtn.onclick = () => exportShader('vert', vertTA.value);
      vertPanel.querySelector('.panel-header').appendChild(vertExportBtn);
      const fragExportBtn = document.createElement('button');
      fragExportBtn.textContent = 'Export';
      fragExportBtn.onclick = () => exportShader('frag', fragTA.value);
      fragPanel.querySelector('.panel-header').appendChild(fragExportBtn);
      const fullExportBtn = document.createElement('button');
      fullExportBtn.textContent = 'Export Full';
      fullExportBtn.style.position = 'absolute';
      fullExportBtn.classList.add('expbtn');
      fullExportBtn.onclick = exportFullHTML;
      previewPanel.appendChild(fullExportBtn);
    }
    window.addEventListener('load', () => {
      initSplit();
      addExportButtons();
    });
    window.addEventListener('resize', initSplit);
    ['mousedown', 'touchstart'].forEach(evt => {
      rowDivider.addEventListener(evt, e => {
        drag.type = 'row';
        drag.startPos = e.clientY || e.touches[0].clientY;
        drag.startSize = vertPanel.getBoundingClientRect().height;
        e.preventDefault();
      }, { passive: false });
      divider.addEventListener(evt, e => {
        drag.type = 'col';
        drag.startPos = e.clientX || e.touches[0].clientX;
        drag.startSize = editors.getBoundingClientRect().width;
        e.preventDefault();
      }, { passive: false });
    });
    ['mousemove', 'touchmove'].forEach(evt => {
      document.addEventListener(evt, e => {
        if (!drag.type) return;
        const pos = evt.includes('touch') ? 
          (e.touches[0][drag.type === 'row' ? 'clientY' : 'clientX']) : 
          (e[drag.type === 'row' ? 'clientY' : 'clientX']);
        if (drag.type === 'row') {
          const dy = pos - drag.startPos;
          const totalH = editors.clientHeight - rowDivider.offsetHeight;
          let topH = Math.max(50, Math.min(totalH - 50, drag.startSize + dy));
          vertPanel.style.height = topH + 'px';
          fragPanel.style.height = (totalH - topH) + 'px';
        } else {
          const newW = Math.max(100, Math.min(app.clientWidth - 100, drag.startSize + pos - drag.startPos));
          editors.style.width = newW + 'px';
        }
        resizeCanvas();
        e.preventDefault();
      });
    });
    ['mouseup', 'touchend', 'touchcancel'].forEach(evt => {
      document.addEventListener(evt, () => drag.type = null);
    });
    function handleFile(input, ta) {
      if (!input.files.length) return;
      const r = new FileReader();
      r.onload = e => { ta.value = e.target.result; rebuildProgram(); };
      r.readAsText(input.files[0]);
    }
    [vertTA, fragTA].forEach(ta => ta.addEventListener('input', rebuildProgram));
    vertFile.addEventListener('change', () => handleFile(vertFile, vertTA));
    fragFile.addEventListener('change', () => handleFile(fragFile, fragTA));
    fsBtn.addEventListener('click', () => {
      const fsElement = document.fullscreenElement || document.webkitFullscreenElement;
      if (!fsElement) {
        const request = previewPanel.requestFullscreen || previewPanel.webkitRequestFullscreen;
        request.call(previewPanel);
      } else {
        const exit = document.exitFullscreen || document.webkitExitFullscreen;
        exit.call(document);
      }
    });
    ['fullscreenchange', 'webkitfullscreenchange'].forEach(evt => {
      document.addEventListener(evt, () => {
        resizeCanvas();
        fsBtn.textContent = (document.fullscreenElement || document.webkitFullscreenElement) ? '✕' : '⛶';
      });
    });
    rebuildProgram();
    render();
  })();
  </script>
</body>
</html>